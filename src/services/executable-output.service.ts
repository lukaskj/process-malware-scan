import { mkdir, readFile, writeFile } from "fs/promises";
import { join } from "path";
import { Service } from "typedi";
import { IExecutable } from "../contracts/executable.interface";
import { OutputJson } from "../services/types";
import { isNullOrUndefined } from "../utils/is-null-or-undefined";

@Service()
export class ExecutableOutputService {
  public async saveExecutablesToJson(
    executableList: IExecutable[],
    outputDir: string,
    inputFile?: OutputJson,
  ): Promise<void> {
    const output: OutputJson = {
      all: executableList,
      allHashes: inputFile?.allHashes ?? {},
      status: inputFile?.status ?? {},
    };

    for (const i of executableList) {
      if (i.error) {
        continue;
      }

      // All hahes
      if (isNullOrUndefined(output.allHashes[i.hash])) {
        output.allHashes[i.hash] = i;
      }

      // Status
      if (isNullOrUndefined(output.status[i.hash])) {
        output.status[i.hash] = {};
      }
    }

    await mkdir(outputDir, { recursive: true });
    await writeFile(join(outputDir, "output.json"), JSON.stringify(output));
  }

  public async loadOutputFile(path?: string): Promise<OutputJson | undefined> {
    if (isNullOrUndefined(path)) {
      return;
    }

    try {
      const fileBuffer = await readFile(path);
      const jsonContents = JSON.parse(fileBuffer.toString());
      if (
        jsonContents &&
        typeof jsonContents === "object" &&
        "all" in jsonContents &&
        Array.isArray(jsonContents.all) &&
        "allHashes" in jsonContents &&
        typeof jsonContents.allHashes === "object" &&
        "status" in jsonContents &&
        typeof jsonContents.status === "object"
      ) {
        return jsonContents as OutputJson;
      }
    } catch (error) {
      console.error(error);
    }
    return;
  }
}
