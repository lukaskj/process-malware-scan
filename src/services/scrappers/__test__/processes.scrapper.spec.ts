import { createMock } from "@golevelup/ts-jest";
import { Powershell } from "../../../utils/powershell";
import { ProcessesScrapper } from "../processes.scrapper";
import {
  PROCESSES_LIST_CLEAN_OUTPUT,
  PROCESSES_LIST_WITH_EMPTY_LINE_OUTPUT,
  PROCESSES_LIST_WITH_HEADER_OUTPUT,
  PROCESS_LIST_EXECUTABLES,
  PROCESS_LIST_EXPECTED_LIST,
} from "./factories/processes.factory";

describe("Scrappers", () => {
  describe("ProcessesScrapper", () => {
    let service: ProcessesScrapper;
    const shell = createMock<Powershell>();

    beforeEach(() => {
      service = new ProcessesScrapper(shell);
    });

    it("should not include empty lines", async () => {
      // given
      jest.spyOn(shell, "run").mockResolvedValueOnce(PROCESSES_LIST_WITH_EMPTY_LINE_OUTPUT);

      // when
      const result = await service.listExecutables();

      // then
      expect(result).not.toBeNull();
      expect(result.length).toBe(PROCESS_LIST_EXECUTABLES.length);
      expect(result).toMatchObject(PROCESS_LIST_EXPECTED_LIST);
    });

    it("should not include 'ExecutablePath' line (first line)", async () => {
      // given
      jest.spyOn(shell, "run").mockResolvedValueOnce(PROCESSES_LIST_WITH_HEADER_OUTPUT);

      // when
      const result = await service.listExecutables();

      // then
      expect(result).not.toBeNull();
      expect(result.length).toBe(PROCESS_LIST_EXECUTABLES.length);
      expect(result).toMatchObject(PROCESS_LIST_EXPECTED_LIST);
    });

    it("should return correct executable list", async () => {
      // given
      jest.spyOn(shell, "run").mockResolvedValueOnce(PROCESSES_LIST_CLEAN_OUTPUT);

      // when
      const result = await service.listExecutables();

      // then
      expect(result).not.toBeNull();
      expect(result.length).toBe(PROCESS_LIST_EXECUTABLES.length);
      expect(result).toMatchObject(PROCESS_LIST_EXPECTED_LIST);
    });
  });
});
