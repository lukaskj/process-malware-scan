import { Container, Service } from "typedi";
import { IExecutable } from "../contracts/executable.interface";
import { AnyType } from "../types";
import { filePathEnvReplace } from "../utils/file-path-env-replace";
import { ExecutableService } from "./executable-service";
import { ProcessesScrapper, ScheduledTasksScrapper, ServicesScrapper } from "./scrappers";
import { IScrapper } from "./scrappers/scrapper.interface";
import { ScrapperMetadataResult } from "./types";
import { Ui } from "../ui";

@Service()
export class AppService {
  constructor(private readonly executableService: ExecutableService, private readonly ui: Ui) {}

  private readonly scrappers: (new (...args: AnyType[]) => IScrapper)[] = [
    ProcessesScrapper,
    ScheduledTasksScrapper,
    ServicesScrapper,
  ];

  public async start(): Promise<void> {
    const scrapperMetadata = await this.runAllScrappersAndGetExecutableMetadata();
    const allExecutables = scrapperMetadata.executables;

    this.replacePathsWithEnvVariables(allExecutables);

    console.log(" - ");
    this.ui.initMultiBars(scrapperMetadata.metadata, "Calculating hashes...");
    let cached = 0;
    const hashCache = new Map<string, IExecutable>();
    for (const executable of allExecutables) {
      if (hashCache.has(executable.path)) {
        cached++;
        const alreadyHashCalculatedExecutable = hashCache.get(executable.path);
        executable.hash = alreadyHashCalculatedExecutable?.hash;
      } else {
        executable.hash = await this.calculateExecutableHash(executable);
        hashCache.set(executable.path, executable);
      }
      this.ui.incrementBar(executable.source);
    }

    this.ui.stopBars();

    if (process.env.DEBUG) {
      console.log(`[+] Total: ${allExecutables.length}. Cached ${cached}.`);
    } else {
      console.log(`[+] Total: ${allExecutables.length}.`);
    }
    // await writeFile("output.json", JSON.stringify(allExecutables));
    return;
  }

  private async runAllScrappersAndGetExecutableMetadata(): Promise<ScrapperMetadataResult> {
    const listExectableMethods = [];

    for (const scConstructor of this.scrappers) {
      const scrapperInstance = Container.get<IScrapper>(scConstructor);
      listExectableMethods.push(scrapperInstance.listExecutables());
    }

    const allListExecutableMethodsResults = await Promise.all(listExectableMethods);

    // allListExecutableMethodsResults.forEach((i) => console.log(i.length));

    const executables = allListExecutableMethodsResults.reduce((prev, cur) => prev.concat(cur), []);

    const metadata: Record<string, number> = {};
    for (const executableListFromScrapper of allListExecutableMethodsResults) {
      if (executableListFromScrapper.length) {
        metadata[executableListFromScrapper[0].source] = executableListFromScrapper.length;
      }
    }

    return {
      executables,
      metadata,
    };
  }

  private replacePathsWithEnvVariables(executables: IExecutable[]): void {
    for (const executable of executables) {
      if (executable.path.indexOf("%") >= 0) {
        executable.path = filePathEnvReplace(executable.path);
      }
    }
  }

  private async calculateExecutableHash(executable: IExecutable): Promise<string> {
    try {
      return await this.executableService.sha256Stream(executable.path);
    } catch (error) {
      return "";
    }
  }
}
