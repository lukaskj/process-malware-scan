import { Container, Service } from "typedi";
import { IExecutable } from "../contracts/executable.interface";
import { AnyType } from "../types";
import { filePathEnvReplace } from "../utils/file-path-env-replace";
import { ExecutableService } from "./executable-service";
import { ProcessesScrapper, ScheduledTasksScrapper, ServicesScrapper } from "./scrappers";
import { IScrapper } from "./scrappers/scrapper.interface";

@Service()
export class AppService {
  constructor(private readonly executableService: ExecutableService) {}

  private readonly scrappers: (new (...args: AnyType[]) => IScrapper)[] = [
    ProcessesScrapper,
    ScheduledTasksScrapper,
    ServicesScrapper,
  ];

  public async start(): Promise<void> {
    const allExecutables = await this.runAllScrappersAndGetExecutableList();

    this.replacePathsWithEnvVariables(allExecutables);

    const totalExecutables = allExecutables.length;

    const hashCache = new Map<string, IExecutable>();
    for (const executable of allExecutables) {
      if (hashCache.has(executable.path)) {
        const alreadyHashCalculatedExecutable = hashCache.get(executable.path);
        executable.hash = alreadyHashCalculatedExecutable?.hash;
      } else {
        executable.hash = await this.calculateExecutableHash(executable);
        hashCache.set(executable.path, executable);
      }
    }

    // await writeFile("output.json", JSON.stringify(allExecutables));
    return;
  }

  private async runAllScrappersAndGetExecutableList(): Promise<IExecutable[]> {
    const listExectableMethods = [];

    for (const scConstructor of this.scrappers) {
      const scrapperInstance = Container.get<IScrapper>(scConstructor);
      console.log(scrapperInstance.name);
      listExectableMethods.push(scrapperInstance.listExecutables());
    }

    const allListExecutableMethodsResults = await Promise.all(listExectableMethods);

    allListExecutableMethodsResults.forEach((i) => console.log(i.length));

    return allListExecutableMethodsResults.reduce((prev, cur) => prev.concat(cur), []);
  }

  private replacePathsWithEnvVariables(executables: IExecutable[]): void {
    for (const executable of executables) {
      if (executable.path.indexOf("%") >= 0) {
        executable.path = filePathEnvReplace(executable.path);
      }
    }
  }

  private async calculateExecutableHash(executable: IExecutable): Promise<string> {
    try {
      return await this.executableService.sha256Stream(executable.path);
    } catch (error) {
      return "";
    }
  }
}
