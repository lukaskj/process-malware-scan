import { Container, Service } from "typedi";
import { IExecutable } from "../contracts/executable.interface";
import { AnyType } from "../types";
import { Ui } from "../ui";
import { filePathEnvReplace } from "../utils/file-path-env-replace";
import { progressBarExecutableMetadata } from "../utils/progress-bar-executable-metadata";
import { ExecutableService } from "./executable-service";
import { ProcessesScrapper, ScheduledTasksScrapper, ServicesScrapper } from "./scrappers";
import { IScrapper } from "./scrappers/scrapper.interface";
import { TOptions } from "./types";

@Service()
export class AppService {
  constructor(
    private readonly executableService: ExecutableService,
    private readonly ui: Ui,
  ) {}

  private readonly scrappers: (new (...args: AnyType[]) => IScrapper)[] = [
    ProcessesScrapper,
    ScheduledTasksScrapper,
    ServicesScrapper,
  ];

  public async start(opts: TOptions): Promise<void> {
    await this.run(opts);
  }

  private async run(opts: TOptions): Promise<void> {
    const allExecutables = await this.runAllScrappersAndGetExecutableMetadata(opts);

    this.replacePathsWithEnvVariables(allExecutables);

    console.log(" - ");
    const progressbarMetadata = progressBarExecutableMetadata(allExecutables);
    this.ui.initMultiBars(progressbarMetadata, "Calculating hashes...");
    let cached = 0;
    let withErrors = 0;
    const hashCache = new Map<string, IExecutable>();
    for (const executable of allExecutables) {
      if (hashCache.has(executable.path)) {
        cached++;
        const alreadyHashCalculatedExecutable = hashCache.get(executable.path);
        executable.hash = alreadyHashCalculatedExecutable?.hash;
      } else {
        executable.hash = await this.calculateExecutableHash(executable);
        if (executable.hash.startsWith("ERROR:")) {
          withErrors++;
        }
        hashCache.set(executable.path, executable);
      }
      this.ui.incrementBar(executable.source);
    }

    this.ui.stopBars();

    if (process.env.DEBUG) {
      console.log(`[+] Total: ${allExecutables.length}. Cached ${cached}.`);
    } else {
      console.log(`[+] Total: ${allExecutables.length}.`);
    }

    console.log(`[+] Errors: ${withErrors}.`);
    // await writeFile("output.json", JSON.stringify(allExecutables));
    return;
  }

  private async runAllScrappersAndGetExecutableMetadata(opts: TOptions): Promise<IExecutable[]> {
    const listExectableMethods = [];

    for (const scConstructor of this.scrappers) {
      const scrapperInstance = Container.get<IScrapper>(scConstructor);
      if (opts.scrappers[scrapperInstance.optionName]) {
        listExectableMethods.push(scrapperInstance.listExecutables());
      }
    }

    const allListExecutableMethodsResults = await Promise.all(listExectableMethods);

    // allListExecutableMethodsResults.forEach((i) => console.log(i.length));

    const executables = allListExecutableMethodsResults.reduce((prev, cur) => prev.concat(cur), []);

    return executables;
  }

  private replacePathsWithEnvVariables(executables: IExecutable[]): void {
    for (const executable of executables) {
      if (executable.path.indexOf("%") >= 0) {
        executable.path = filePathEnvReplace(executable.path);
      }
    }
  }

  private async calculateExecutableHash(executable: IExecutable): Promise<string> {
    try {
      return await this.executableService.sha256Stream(executable.path);
    } catch (error) {
      if (error instanceof Error) {
        return `ERROR: ${error.message}`;
      }
      return "ERROR: ";
    }
  }
}
