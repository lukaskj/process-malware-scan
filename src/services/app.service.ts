import { Container, Service } from "typedi";
import { writeFile } from "fs/promises";
import { IExecutable } from "../contracts/executable.interface";
import { AnyType } from "../types";
import { Ui } from "../ui";
import { filePathEnvReplace } from "../utils/file-path-env-replace";
import { progressBarExecutableMetadata } from "../utils/progress-bar-executable-metadata";
import { ExecutableService } from "./executable-service";
import { ProcessesScanner, ScheduledTasksScanner, ServicesScanner } from "./scanners";
import { IScanner } from "./scanners/scanner.interface";
import { TOptions } from "./types";
import { ExecutableOutputService } from "./executable-output.service";

@Service()
export class AppService {
  constructor(
    private readonly executableService: ExecutableService,
    private readonly ui: Ui,
    private readonly executableOutputService: ExecutableOutputService,
  ) {}

  private readonly scanners: (new (...args: AnyType[]) => IScanner)[] = [
    ProcessesScanner,
    ScheduledTasksScanner,
    ServicesScanner,
  ];

  public async start(opts: TOptions): Promise<void> {
    const executableList = await this.scan(opts);
    await this.calculateHashes(executableList);
    await this.executableOutputService.saveExecutablesToJson(executableList, opts);
  }

  private async scan(opts: TOptions): Promise<IExecutable[]> {
    const allExecutables = await this.runAllScannersAndGetExecutableMetadata(opts);

    this.replacePathsWithEnvVariables(allExecutables);

    return allExecutables;
  }

  private async calculateHashes(allExecutables: IExecutable[]): Promise<void> {
    console.log(" - ");
    const progressbarMetadata = progressBarExecutableMetadata(allExecutables);
    this.ui.initMultiBars(progressbarMetadata, "Calculating hashes...");
    let cached = 0;
    let withErrors = 0;
    const hashCache = new Map<string, IExecutable>();
    for (const executable of allExecutables) {
      if (hashCache.has(executable.path)) {
        cached++;
        const alreadyHashCalculatedExecutable = hashCache.get(executable.path);
        executable.hash = alreadyHashCalculatedExecutable?.hash ?? "";
      } else {
        executable.hash = await this.calculateExecutableHash(executable);
        if (executable.hash.startsWith("ERROR:")) {
          withErrors++;
        }
        hashCache.set(executable.path, executable);
      }
      this.ui.incrementBar(executable.source);
    }

    this.ui.stopBars();

    if (process.env.DEBUG) {
      console.log(`[+] Total: ${allExecutables.length}. Cached ${cached}.`);
    } else {
      console.log(`[+] Total: ${allExecutables.length}.`);
    }

    console.log(`[+] Errors: ${withErrors}.`);
  }

  private async runAllScannersAndGetExecutableMetadata(opts: TOptions): Promise<IExecutable[]> {
    const listExectableMethods = [];

    for (const scConstructor of this.scanners) {
      const scannerInstance = Container.get<IScanner>(scConstructor);
      if (opts.scanners[scannerInstance.optionName]) {
        listExectableMethods.push(scannerInstance.listExecutables());
      }
    }

    const allListExecutableMethodsResults = await Promise.all(listExectableMethods);

    // allListExecutableMethodsResults.forEach((i) => console.log(i.length));

    const executables = allListExecutableMethodsResults.reduce((prev, cur) => prev.concat(cur), []);

    return executables;
  }

  private replacePathsWithEnvVariables(executables: IExecutable[]): void {
    for (const executable of executables) {
      if (executable.path.indexOf("%") >= 0) {
        executable.path = filePathEnvReplace(executable.path);
      }
    }
  }

  private async calculateExecutableHash(executable: IExecutable): Promise<string> {
    try {
      return await this.executableService.sha256Stream(executable.path);
    } catch (error) {
      if (error instanceof Error) {
        return `ERROR: ${error.message}`;
      }
      return "ERROR: ";
    }
  }

  private async saveToJson(executableList: IExecutable[], _opts: TOptions): Promise<void> {
    await writeFile("output.json", JSON.stringify(executableList));
  }
}
