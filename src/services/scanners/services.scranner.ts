import { Service } from "typedi";
import { IExecutable } from "../../contracts/executable.interface";
import { Executable } from "../../entities/executable.entity";
import { ServiceExecutable } from "../../entities/service-executable.entity";
import { ExecutableSource } from "../../enum/executable-source.enum";
import { Powershell } from "../../utils/powershell";
import { IScanner } from "./scanner.interface";

@Service()
export class ServicesScanner implements IScanner {
  public name: string = "New Services";
  public optionName: string = "service";
  public source = ExecutableSource.SERVICE;

  constructor(private shell: Powershell) {}

  // eslint-disable-next-line sonarjs/cognitive-complexity
  public async listExecutables(): Promise<IExecutable[]> {
    console.log("Listing services...");
    const output = await this.shell.run(['"Get-WmiObject win32_service | select DisplayName, State, PathName | fl"']);
    const executables: Executable[] = [];

    const headers = ["DisplayName", "State", "PathName"] as const;
    const headersMapToExecutableObj = {
      DisplayName: "name",
      State: "status",
      PathName: "path",
    } as const;

    let headerIndex = 0;

    const lines = output.split("\n");
    let start = 0;
    for (let i = 0; i < lines.length; i++) {
      const element = lines[i].trim();
      if (element !== "") {
        continue;
      }
      start = i;
      break;
    }

    let i = start;
    let executableObject = new ServiceExecutable();
    while (i < lines.length) {
      const curHeader = headers[headerIndex % headers.length];
      const nextHeader = headers[(headerIndex + 1) % headers.length];

      const line = lines[i];
      if (line.trim() === "") {
        i++;
        if (curHeader === headers.at(-1)) {
          // if it is last header, create a new executable object
          executableObject.cleanStrings();
          executableObject.fillArgsFromPath();
          executables.push(executableObject);
          executableObject = new ServiceExecutable();
        }
        continue;
      }

      const objKey = headersMapToExecutableObj[curHeader];

      if (this.isNextHeader(line, curHeader, nextHeader)) {
        headerIndex++;
        continue;
      }

      const commaI = line.indexOf(":");
      const value = line.substring(commaI + 1);

      executableObject[objKey] = (executableObject[objKey] || "") + value;
      i++;
    }

    return executables.filter((ex) => ex.name.trim() !== "");
  }

  private isNextHeader(line: string, curHeader: string, nextHeader: string): boolean {
    if (
      !line.startsWith(curHeader) &&
      line.startsWith(nextHeader) &&
      (line[nextHeader.length + 1] === " " || line[nextHeader.length + 1] === ":")
    ) {
      return true;
    }
    return false;
  }
}
