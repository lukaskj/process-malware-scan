import { IExecutable } from "@domain/interfaces/executable.interface";
import { IScanner } from "@domain/interfaces/scanner.interface";
import { Ui } from "@interface/ui";
import { Container, Service } from "typedi";
import { ClassConstructor } from "../../types";
import { filePathEnvReplace } from "../utils/file-path-env-replace";
import { progressBarExecutableMetadata } from "../utils/progress-bar-executable-metadata";
import { ExecutableService } from "./executable-service";
import { ExternalFileService } from "./external-file.service";
import { ProcessesScanner, ScheduledTasksScanner, ServicesScanner } from "./scanners";
import { TOptions } from "./types";
import { AnalizerService } from "./analyzer.service";

@Service()
export class AppService {
  constructor(
    private readonly executableService: ExecutableService,
    private readonly ui: Ui,
    private readonly externalFileService: ExternalFileService,
    private readonly analizerService: AnalizerService,
  ) {}

  private readonly scanners: ClassConstructor<IScanner>[] = [ProcessesScanner, ScheduledTasksScanner, ServicesScanner];

  public async start(opts: TOptions): Promise<void> {
    const inputFilePath = opts.inputFile;
    const inputFile = await this.externalFileService.loadOutputFile(inputFilePath);
    const cacheFile = await this.externalFileService.loadCacheFile(opts.cacheFile);
    if (inputFile) {
      inputFile.status = { ...inputFile.status, ...cacheFile };
    }

    const executableList = await this.scan(opts);
    await this.calculateHashes(executableList);
    const resultFile = await this.externalFileService.saveExecutablesToJson(executableList, opts.outputDir, inputFile);
    await this.externalFileService.saveCacheFile(opts.cacheFile, resultFile.status);

    resultFile.status = await this.analizerService.start(resultFile.status, 5);

    await this.externalFileService.saveExecutablesToJson(executableList, opts.outputDir, resultFile);
    await this.externalFileService.saveCacheFile(opts.cacheFile, resultFile.status);
  }

  private async scan(opts: TOptions): Promise<IExecutable[]> {
    const allExecutables = await this.runAllScannersAndGetExecutableMetadata(opts);

    this.replacePathsWithEnvVariables(allExecutables);

    return allExecutables;
  }

  private async calculateHashes(allExecutables: IExecutable[]): Promise<void> {
    console.log(" - ");
    const progressbarMetadata = progressBarExecutableMetadata(allExecutables);
    this.ui.initMultiBars(progressbarMetadata, "Calculating hashes...");

    let cached = 0;
    let withErrors = 0;
    const hashCache = new Map<string, IExecutable>();

    for (const executable of allExecutables) {
      if (hashCache.has(executable.path)) {
        cached++;
        const alreadyHashCalculatedExecutable = hashCache.get(executable.path);
        executable.hash = alreadyHashCalculatedExecutable?.hash ?? "";
        executable.error = alreadyHashCalculatedExecutable?.error;
      } else {
        executable.hash = await this.calculateExecutableHash(executable);

        if (executable.hash.startsWith("ERROR:")) {
          withErrors++;
          executable.error = true;
        }

        hashCache.set(executable.path, executable);
      }

      this.ui.incrementBar(executable.source);
    }

    this.ui.stopBars();

    if (process.env.DEBUG) {
      console.log(`[+] Total: ${allExecutables.length}. Cached ${cached}.`);
    } else {
      console.log(`[+] Total: ${allExecutables.length}.`);
    }

    console.log(`[+] Errors: ${withErrors}.`);
  }

  private async runAllScannersAndGetExecutableMetadata(opts: TOptions): Promise<IExecutable[]> {
    const listExectableMethods = [];

    for (const scConstructor of this.scanners) {
      const scannerInstance = Container.get<IScanner>(scConstructor);
      if (opts.scanners[scannerInstance.optionName]) {
        listExectableMethods.push(scannerInstance.listExecutables());
      }
    }

    const allListExecutableMethodsResults = await Promise.all(listExectableMethods);

    // allListExecutableMethodsResults.forEach((i) => console.log(i.length));

    const executables = allListExecutableMethodsResults.reduce((prev, cur) => prev.concat(cur), []);

    return executables;
  }

  private replacePathsWithEnvVariables(executables: IExecutable[]): void {
    for (const executable of executables) {
      if (executable.path.indexOf("%") >= 0) {
        executable.path = filePathEnvReplace(executable.path);
      }
    }
  }

  private async calculateExecutableHash(executable: IExecutable): Promise<string> {
    try {
      return await this.executableService.sha256Stream(executable.path);
    } catch (error) {
      if (error instanceof Error) {
        return `ERROR: ${error.message}`;
      }
      return "ERROR: ";
    }
  }
}
