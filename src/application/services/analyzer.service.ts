import { HashStatus } from "@domain/interfaces/hash-status.interface";
import { HashAnalyzeStatus, IOutputExecutableStatus } from "@domain/interfaces/output-executable-status.interface";
import { Service } from "typedi";
import { sleep } from "../utils/sleep";
import { VirusTotalScrapAnalyzerService } from "./analyzers/virustotal-scrap-analyzer.service";

@Service()
export class AnalizerService {
  constructor(private readonly virusTotalScrapAnalyzerService: VirusTotalScrapAnalyzerService) {}

  public async start(
    allHashes: HashStatus,
    batch: number,
    loopTimeout: number,
    loopBatchTimeout: number,
  ): Promise<HashStatus> {
    const hashes = Object.keys(allHashes);
    console.log(`[+] Total to analyze: ${hashes.length}. Batch size: ${batch}.`);

    const promises: Promise<IOutputExecutableStatus>[] = [];
    try {
      for (let i = 0; i < hashes.length; i++) {
        const hash = hashes[i];

        const currentStatus = allHashes[hash];
        if (!this._shouldAnalyze(currentStatus)) {
          continue;
        }

        const toAnalyze = this.virusTotalScrapAnalyzerService.analyzeHash(hash);
        await sleep(loopTimeout);

        promises.push(toAnalyze);
        if ((i + 1) % batch === 0 || i + batch + 1 > hashes.length) {
          console.log(`  Analyzing current: ${i + 1}.`);

          const results = await Promise.all(promises);
          for (const result of results) {
            allHashes[result.hash] = result;
          }

          await this.virusTotalScrapAnalyzerService.dispose();

          await sleep(loopBatchTimeout);
        }
      }
    } finally {
      await this.virusTotalScrapAnalyzerService.dispose();
    }

    return allHashes;
  }

  private _shouldAnalyze(currentStatus: IOutputExecutableStatus): boolean {
    return currentStatus.status === HashAnalyzeStatus.WAITING || currentStatus.status === HashAnalyzeStatus.ERROR;
  }
}
