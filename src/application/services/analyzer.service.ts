import { HashStatus } from "@domain/interfaces/hash-status.interface";
import { HashAnalyzeStatus, IOutputExecutableStatus } from "@domain/interfaces/output-executable-status.interface";
import { Ui } from "@interface/ui";
import { Service } from "typedi";
import { sleep } from "../utils/sleep";
import { VirusTotalScrapAnalyzerService } from "./analyzers/virustotal-scrap-analyzer.service";

@Service()
export class AnalizerService {
  constructor(
    private readonly virusTotalScrapAnalyzerService: VirusTotalScrapAnalyzerService,
    private readonly ui: Ui,
  ) {}

  public async start(
    allHashes: HashStatus,
    batch: number,
    loopTimeout: number,
    loopBatchTimeout: number,
  ): Promise<HashStatus> {
    const hashes = Object.keys(allHashes);
    const totalHashes = hashes.length;
    console.log(`[+] Unique hashes to analyze: ${totalHashes}. Batch size: ${batch}.`);
    const barId = "Analizing hashes";
    this.ui.initMultiBars({
      [barId]: totalHashes,
    });

    const promises: Promise<IOutputExecutableStatus>[] = [];
    try {
      for (let i = 0; i < totalHashes; i++) {
        this.ui.incrementBar(barId, 1);
        const hash = hashes[i];

        const currentStatus = allHashes[hash];
        if (!this._shouldAnalyze(currentStatus)) {
          continue;
        }

        const toAnalyze = this.virusTotalScrapAnalyzerService.analyzeHash(hash);
        await sleep(loopTimeout);

        promises.push(toAnalyze);
        if ((i + 1) % batch === 0 || i + batch + 1 > totalHashes) {
          // console.log(`  Analyzing current: ${i + 1}.`);
          const results = await Promise.all(promises);
          let hasRecaptcha = false;
          for (const result of results) {
            allHashes[result.hash] = result;
            hasRecaptcha = hasRecaptcha || result.status === HashAnalyzeStatus.CAPTCHA;
          }

          await this.virusTotalScrapAnalyzerService.dispose();

          if (hasRecaptcha) {
            console.log("[+] Captcha found.");
            await this.virusTotalScrapAnalyzerService.handleCaptcha(hash);
          }

          await sleep(loopBatchTimeout);
        }
      }
    } finally {
      this.ui.stopBars();
      await this.virusTotalScrapAnalyzerService.dispose();
    }

    return allHashes;
  }

  private _shouldAnalyze(currentStatus: IOutputExecutableStatus): boolean {
    return ![HashAnalyzeStatus.MALICIOUS, HashAnalyzeStatus.NOT_MALICIOUS].includes(currentStatus.status);
  }
}
