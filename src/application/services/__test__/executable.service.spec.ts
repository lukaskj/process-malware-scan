import { faker } from "@faker-js/faker";
import fs from "node:fs";
import Container from "typedi";
import { ExecutableService } from "../executable-service";

describe("Services", () => {
  beforeEach(() => {
    jest.resetAllMocks();
  });

  afterAll(() => {
    jest.resetAllMocks();
    jest.restoreAllMocks();
  });

  describe("Executable Service", () => {
    it("should fail when trying to hash an inexisting file", async () => {
      // given
      const service = Container.get(ExecutableService);
      const filePath = faker.system.filePath();
      const fileContent = "456789123465";
      const expectedExcpetion = `File ${filePath} not found.`;

      const fileExists$ = jest.spyOn(fs, "existsSync").mockReturnValueOnce(false);
      const readFile$ = jest.spyOn(fs.promises, "readFile").mockResolvedValueOnce(fileContent);

      // when
      const calculatedHash = service.sha256(filePath);

      // then
      await expect(calculatedHash).rejects.toThrow(expectedExcpetion);
      expect(fileExists$).toHaveBeenCalled();
      expect(readFile$).not.toHaveBeenCalled();
    });

    it("should successfully hash an existing file", async () => {
      // given
      const service = Container.get(ExecutableService);
      const filePath = faker.system.filePath();
      const fileContent = "456789123465";
      const expectedHash = "f38b4b7129ffbe4d525af5cee12d4b8a485b27598e56519d17f76b52c9fb7802";

      const fileExists$ = jest.spyOn(fs, "existsSync").mockReturnValueOnce(true);
      const readFile$ = jest.spyOn(fs.promises, "readFile").mockResolvedValueOnce(fileContent);

      // when
      const calculatedHash = await service.sha256(filePath);

      // then
      expect(calculatedHash).toBe(expectedHash);
      expect(fileExists$).toHaveBeenCalled();
      expect(readFile$).toHaveBeenCalled();
    });
  });
});
