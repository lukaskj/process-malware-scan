import { isNullOrUndefined } from "@application/utils/is-null-or-undefined";
import { IAnalyzer } from "@domain/interfaces/analyzer.interface";
import { HashAnalyzeStatus, IOutputExecutableStatus } from "@domain/interfaces/output-executable-status.interface";
import { Browser, BrowserContext, Page, chromium } from "playwright";
import { Service } from "typedi";
import { sleep } from "../../utils/sleep";
import { OptsService } from "../opts.service";

const INT_REGEX = /[^0-9]+/g;

@Service()
export class VirusTotalScrapAnalyzerService implements IAnalyzer {
  private baseUrl: string = "https://www.virustotal.com/gui/file/";
  private static __browser: Promise<Browser> | null = null;
  private context: BrowserContext | null = null;

  constructor(private readonly optsService: OptsService) {}

  private async getBrowser(headless: boolean = true): Promise<Browser> {
    if (isNullOrUndefined(VirusTotalScrapAnalyzerService.__browser)) {
      VirusTotalScrapAnalyzerService.__browser = chromium.launch({
        headless: !headless ? headless : !this.optsService.opts.debug || headless,
      });
    }

    return VirusTotalScrapAnalyzerService.__browser;
  }

  private async getContext(headless: boolean = true): Promise<BrowserContext> {
    if (isNullOrUndefined(this.context)) {
      const browser = await this.getBrowser(headless);
      this.context = await browser.newContext();
    }

    return this.context;
  }

  public async analyzeHash(hash: string): Promise<IOutputExecutableStatus> {
    const url = `${this.baseUrl}${hash}`;

    const context = await this.getContext();
    const page = await context.newPage();

    try {
      await page.goto(url);

      const pageErrors = await this.getPageErrors(page, hash);
      if (!isNullOrUndefined(pageErrors)) {
        if (this.optsService.opts.debug) {
          console.debug("[D] Page errors found.", pageErrors);
        }
        return pageErrors;
      }

      // document.querySelector('vt-ui-shell file-view').shadowRoot.querySelector('#report').shadowRoot.querySelector('vt-ui-detections-widget').shadowRoot.querySelector('.circle .positives')
      const rawPositives = await page.locator(".circle .positives").innerText();
      const rawTotal = await page.locator(".circle .total").innerText();
      const positives = parseInt(rawPositives.replace(INT_REGEX, "").trim());
      const total = parseInt(rawTotal.replace(INT_REGEX, "").trim());

      if (this.optsService.opts.debug) {
        console.debug("[D] Document texts", {
          rawPositives,
          rawTotal,
        });
      }

      if (isNaN(positives) || isNaN(total)) {
        return {
          hash,
          positives: -1,
          total: -1,
          status: HashAnalyzeStatus.ERROR,
          errorMessage: `Error. URL: ${page.url()}`,
        };
      }

      return {
        hash,
        positives,
        total,
        status: positives > 0 ? HashAnalyzeStatus.MALICIOUS : HashAnalyzeStatus.NOT_MALICIOUS,
      };
    } catch (e) {
      return {
        hash,
        positives: -1,
        total: -1,
        status: HashAnalyzeStatus.ERROR,
        errorMessage: `Exception: ${
          e && typeof e === "object" && "message" in e && typeof e.message === "string" ? e.message : "..."
        }`,
      };
    } finally {
      await page.close();
    }
  }

  private async getPageErrors(page: Page, hash: string): Promise<IOutputExecutableStatus | null> {
    const hashWasScanned = await page.isVisible(".circle .positives");
    const hashNotFound = await page.isVisible("img[src='images/error-item-not-found.png']");

    const isRecaptchaUrl = page.url().indexOf("/captcha") >= 0;
    let hasRecaptcha = false;
    if ((hashNotFound && !hashWasScanned) || isRecaptchaUrl) {
      await sleep(500);
      hasRecaptcha = (await page.isVisible("#captchaContainer")) || isRecaptchaUrl;
    }

    if (hasRecaptcha) {
      return {
        hash,
        positives: -1,
        total: -1,
        status: HashAnalyzeStatus.CAPTCHA,
        errorMessage: `Recaptcha. Error. URL: ${page.url()}.`,
      };
    }

    if (hashNotFound) {
      return {
        hash,
        positives: -1,
        total: -1,
        status: HashAnalyzeStatus.NOT_FOUND,
      };
    }

    if (!hashWasScanned) {
      return {
        hash,
        positives: -1,
        total: -1,
        status: HashAnalyzeStatus.ERROR,
        errorMessage: `Not scanned.`,
      };
    }

    return null;
  }

  public async handleCaptcha(hash: string): Promise<boolean> {
    const url = `${this.baseUrl}${hash}`;
    const waitMs = 60000;

    try {
      await this.dispose();
      await sleep(1000);
      const context = await this.getContext(false);
      const page = await context.newPage();

      await page.goto(url);
      console.log(`    Waiting ${Math.round(waitMs / 1000)}s for captcha.`);
      await sleep(60000);
    } catch (e) {
      console.error(e);
      return false;
    } finally {
      await this.dispose();
    }

    return true;
  }

  public async dispose(): Promise<void> {
    if (this.context) {
      const context = await this.getContext();
      await context.close();
      this.context = null;
    }

    if (!isNullOrUndefined(VirusTotalScrapAnalyzerService.__browser)) {
      const browser = await this.getBrowser();
      await browser.close();
      // eslint-disable-next-line require-atomic-updates
      VirusTotalScrapAnalyzerService.__browser = null;
    }
  }
}
