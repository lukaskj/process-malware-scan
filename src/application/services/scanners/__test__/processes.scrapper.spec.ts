import { createMock } from "@golevelup/ts-jest";
import { Powershell } from "../../../utils/powershell";
import { ProcessesScanner } from "../processes.scanner";
import {
  PROCESSES_LIST_CLEAN_OUTPUT,
  PROCESSES_LIST_WITH_EMPTY_LINE_OUTPUT,
  PROCESSES_LIST_WITH_HEADER_OUTPUT,
  PROCESS_LIST_EXECUTABLES,
  PROCESS_LIST_EXPECTED_LIST,
} from "./factories/processes.factory";

describe("Scanners", () => {
  describe("ProcessesScanner", () => {
    let service: ProcessesScanner;
    const shell = createMock<Powershell>();

    beforeEach(() => {
      service = new ProcessesScanner(shell);
    });

    it("should not include empty lines", async () => {
      // given
      jest.spyOn(shell, "run").mockResolvedValueOnce(PROCESSES_LIST_WITH_EMPTY_LINE_OUTPUT);

      // when
      const result = await service.listExecutables();

      // then
      expect(result).not.toBeNull();
      expect(result.length).toBe(PROCESS_LIST_EXECUTABLES.length);
      expect(result).toMatchObject(PROCESS_LIST_EXPECTED_LIST);
    });

    it("should not include 'ExecutablePath' line (first line)", async () => {
      // given
      jest.spyOn(shell, "run").mockResolvedValueOnce(PROCESSES_LIST_WITH_HEADER_OUTPUT);

      // when
      const result = await service.listExecutables();

      // then
      expect(result).not.toBeNull();
      expect(result.length).toBe(PROCESS_LIST_EXECUTABLES.length);
      expect(result).toMatchObject(PROCESS_LIST_EXPECTED_LIST);
    });

    it("should return correct executable list", async () => {
      // given
      jest.spyOn(shell, "run").mockResolvedValueOnce(PROCESSES_LIST_CLEAN_OUTPUT);

      // when
      const result = await service.listExecutables();

      // then
      expect(result).not.toBeNull();
      expect(result.length).toBe(PROCESS_LIST_EXECUTABLES.length);
      expect(result).toMatchObject(PROCESS_LIST_EXPECTED_LIST);
    });
  });
});
